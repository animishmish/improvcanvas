<!DOCTYPE html>

<html lang="en">
<head>
		<title>Three JS with Peer JS</title>

	<link rel="stylesheet" href="style.css">
  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  <!-- peer.js webrtc framework -->
  <script type="text/javascript" src="js/peer.js"></script>

  <script type="text/javascript" src="js/statsHandler.js"></script>
  <!-- the chat -->
  <script type="text/javascript" src="js/chat.js"></script>

	<!--meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
			body {
				margin: 0px;
				padding: 0px;
				font-family: 'inconsolata';
				font-size: 15px;
				overflow: hidden;
			}
	</style-->
</head>
<body>

<div id="container" class="pure-g">

    <!-- Video area -->
   

    <!-- Steps -->
    <div class="pure-u-1-3">
      <h2>Test peerjs to threejs</h2>
      <!-- Get local audio/myVideo stream -->
      <div id="step1">
        <p>Please click `allow` on the top of the screen so we can access your webcam and microphone for calls.</p>
        <div id="step1-error">
          <p>Failed to access the webcam and microphone. Make sure to run this demo on an http server and click allow when asked for permission by the browser.</p>
          <a href="#" class="pure-button pure-button-error" id="step1-retry">Try again</a>
        </div>
      </div>

      <!-- Make calls to others -->
      <div id="step2">
        <p>Your id: <span id="my-id">...</span></p>
        <p>Share this id with others so they can call you.</p>


        <h3>Make a call</h3>
        <div class="pure-form">
          <input type="text" placeholder="Call user id..." id="callto-id">
          <a href="#" class="pure-button pure-button-success" id="make-call">Call</a>
        </div>
      </div>

      <!-- Call in progress -->
      <div id="step3">
        <p>Currently in call with <span id="their-id">...</span></p>
        <p><a href="#" class="pure-button pure-button-error" id="end-call">End call</a></p>
      </div>

     

    </div>

    </div>	

<!-- This is a hidden div incase you need it - the camera error message is inside -->

<div hidden>
<p id="errorMessage"></p>
<!--Setting up my webcam myVideo steram and placing it on a canvas-->
<video id="my-video" autoplay  ></video>
<canvas id="myVideoCanvas" ></canvas>

<!--Setting up partners webcam myVideo steram and placing it on a canvas-->
<video id="their-video" autoplay  ></video>
<canvas id="theirVideoCanvas" ></canvas>

</div>

<center>


</center>

<script src="js/three.min.js"></script>
<script src="js/Detector.js"></script>
<script src="js/OrbitControls.js"></script>

<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>

<script src='js/DAT.GUI.min.js'></script>

<!-- <script src='js/sockets.js'></script>
 -->
<!-- SHADER -->
<script id="fragment_shh" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			uniform sampler2D tOne;
			uniform sampler2D tSec;

			varying vec2 vUv;
			varying vec2 vUv2;
			
			void main(void)
			{
				vec3 c;
				vec4 Ca = texture2D(tOne, vUv);
				vec4 Cb = texture2D(tSec, vUv2);
				c = Ca.rgb * Cb.rgb;
			    gl_FragColor= vec4(c, 1.0);
				
			}
			
		</script>

		<script id="vertex_shh" type="x-shader/x-vertex">
		
			varying vec2 vUv;
			varying vec2 vUv2;

			void main()
			{
				// console.log(position);
				float aspect = 4.0 / 3.0;
				float videoXoffset = 0.1;
				vUv = uv;
				vUv2 = vec2(vUv.x, vUv.y);
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}
			
		</script>

<div id="ThreeJS" ></div>	 

<script type="text/javascript"	>

// global VIDEO variables for my video
var myVideo, myVideoCanvas, myVideoCanvasContext,myVideoTexture;

// global VIDEO variables for their video
var theirVideo, theirVideoCanvas, theirVideoCanvasContext,theirVideoTexture;

// GLOBAL THREE.JS VARIABLES
var container, scene, camera, renderer, controls, alon;

//GLOBAL VARS FOR CONTROL AND GUI
var keyboard = new THREEx.KeyboardState();
var sliders;
var gui;
var printed = 1;
var mix ; 

//---- WEBCAM VIDEO STREAM -----

//01.
//My Webcam attributes and style
myVideo = document.getElementById( 'my-video' );
console.log("myVideo",myVideo);
console.log("myVideo width",myVideo.width);
console.log("myVideo height",myVideo.height);
myVideo.width = 640;
myVideo.height = 480;
//myVideo.msHorizontalMirror = true;
myVideo.muted = true;
//myVideo.rotate(180);
myVideo.style.visibility = "visible";

//create variable to offset camera on myVideo texture
var myVideoXpos = 0;
var myVideoYpos = 0;
var myVideoZoom = 1;
var p_deg = 0;

//------ VIDEO CANVAS --------------

//myVideo assigned to a canvas
myVideoCanvas = document.getElementById( 'myVideoCanvas' );
console.log('myVideoCanvas',myVideoCanvas);
//myVideo canvas variables
myVideoCanvas.width = myVideo.width;
myVideoCanvas.height = myVideo.height;

// content of the myVideo canvas
myVideoCanvasContext = myVideoCanvas.getContext( '2d' );
console.log('myVideoCanvasContext',myVideoCanvasContext);

//02.
//Their Webcam attributes and style
theirVideo = document.getElementById( 'their-video' );
theirVideo.width = 640;
theirVideo.height = 480;
theirVideo.muted = true;
theirVideo.style.visibility = "visible";

//create variable to offset camera on myVideo texture
var theirVideoXpos = 0;
var theirVideoYpos = 0;
var theirVideoZoom = 1;

//------ VIDEO CANVAS --------------

//theirVideo assigned to a canvas
theirVideoCanvas = document.getElementById( 'theirVideoCanvas' );

//theirVideo canvas variables
theirVideoCanvas.width = theirVideo.width;
theirVideoCanvas.height = theirVideo.height;
// content of the myVideo canvas
theirVideoCanvasContext = theirVideoCanvas.getContext( '2d' );



//--------------------

// (set up)
init();

// (draw)				
animate();

function init()
{

	// var serverAddress = 'ws://10.0.27.38:8080'; // this is the itpSandbox IP (check your preferences)
	// //var serverAddress = 'ws://localhost:8080';
	// var socket = new WebSocket (serverAddress) ;

	// console.log('attempting connection to '+serverAddress);

	// socket.onopen = function(){
	// console.log('opened!');

	// };

	// socket.onmessage = function(message){
	// 	var data = JSON.parse(message.data);
	// 	console.log(data.type); // look at the type to see where it should go
	// 	console.log(data.value); // and send this number there to update the GUI slider

	// 	if(data.type==='scaleVideo') {
	// 		myVideoZoom = data.value;
	// 	}

	// 	else if (data.type==='rotateScreenZ') {
	// 		movieScreen.rotation.z = data.value;
	// 		slider.rotateScreenZ=data.value;
	// 		//updateSlider();
	// 	};
	// };

	// socket.onclose = function(){
	// console.log('closed!');

	// };

// SCENE
scene = new THREE.Scene();

// CAMERA
var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
scene.add(camera);
camera.position.set(0,150,400);
camera.lookAt(scene.position);

// RENDERER
if ( Detector.webgl )
renderer = new THREE.WebGLRenderer( {antialias:true} );
else
renderer = new THREE.CanvasRenderer();
renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
container = document.getElementById( 'ThreeJS' );
container.appendChild( renderer.domElement );

// CONTROLS
controls = new THREE.OrbitControls( camera, renderer.domElement );

// EVENTS
THREEx.WindowResize(renderer, camera);
THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });

// LIGHT
var ambient = new THREE.AmbientLight( 0x101030 );
scene.add( ambient );

var directionalLight = new THREE.DirectionalLight( 0xffeedd,1);
directionalLight.position.set( 0, 0, 1 );
scene.add( directionalLight );

// ADD FLOOR
	var floorTexture = new THREE.ImageUtils.loadTexture( 'images/checkerboard.jpg' );
	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
	floorTexture.repeat.set( 10, 10 );
	var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.position.y = -50;
	floor.rotation.x = Math.PI / 2;
	scene.add(floor);

// CREATE VIDEO 3D TEXTURE for me
console.log("myVideo width",myVideo.width );
console.log("myVideo height",myVideo.height );
console.log("myVideoCanvas width",myVideoCanvas.width );
console.log("myVideoCanvas height",myVideoCanvas.height );
myVideoTexture = new THREE.Texture( myVideoCanvas );


myVideoTexture.minFilter = THREE.LinearFilter;
myVideoTexture.magFilter = THREE.LinearFilter;

// CREATE VIDEO 3D TEXTURE for partner
theirVideoTexture = new THREE.Texture( theirVideoCanvas );
theirVideoTexture.minFilter = THREE.LinearFilter;
theirVideoTexture.magFilter = THREE.LinearFilter;

///ADDING MULTI LAYER SHADER TEXTURE TO CALIBRATOR SCREEN
	var vertShader = document.getElementById('vertex_shh').innerHTML;
	var fragShader = document.getElementById('fragment_shh').innerHTML;

	var attributes = {}; // custom attributes
	
	//var tex1 = myVideoTexture;
	//var tex2 = THREE.ImageUtils.loadTexture("textures/Alon_head_tex_0.png", {}, function() { renderer.render(scene, camera);});

	var uniforms = {    // custom uniforms (your textures)
	
	tOne: { type: "t", value: theirVideoTexture  },
	tSec: { type: "t", value: myVideoTexture }
	
	};

	var material_shh = new THREE.ShaderMaterial({

  	uniforms: uniforms,
  	attributes: attributes,
  	vertexShader: vertShader,
  	fragmentShader: fragShader

	});

//-------------------------------	


// ADD VIDEO CALLIBRATION SCREEN (center)
//var movieMaterial = new THREE.MeshBasicMaterial( { map: myVideoTexture, overdraw: true, side:THREE.DoubleSide } );
	// the geometry on which the movie will be displayed;
	// 		movie image will be scaled to fit these dimensions.
	


  //Test plane for partners video (right)
  var partnerMaterial = new THREE.MeshBasicMaterial( { 
  	map: theirVideoTexture, 
  	overdraw: true, 
  	side:THREE.DoubleSide, 
 	transparent: true,
            
  } );
  	mix = THREE.MultiplyBlending;
    var bigPartnerMaterial = new THREE.MeshBasicMaterial( { 
  	map: theirVideoTexture, 
  	overdraw: true, 
  	side:THREE.DoubleSide, 
 	transparent: true,
 	blending: mix
            
  } );
  // the geometry on which the movie will be displayed;
  //    movie image will be scaled to fit these dimensions.
  var partnerGeometry = new THREE.PlaneGeometry( (theirVideoCanvas.width/15), (theirVideoCanvas.height/15), 1, 1 );
  var partnerScreen = new THREE.Mesh( partnerGeometry, partnerMaterial );
  partnerScreen.position.set(150,120,30);
  partnerScreen.rotation.y = Math.PI;

  
  scene.add(partnerScreen);

    //Test plane for my video (left)
  var myMaterial = new THREE.MeshBasicMaterial( { map: myVideoTexture, overdraw: true, side:THREE.DoubleSide } );
  // the geometry on which the movie will be displayed;
  //    movie image will be scaled to fit these dimensions.
  var myGeometry = new THREE.PlaneGeometry( (myVideoCanvas.width/15), (myVideoCanvas.height/15), 1, 1 );
  var myScreen = new THREE.Mesh( myGeometry, myMaterial );
  myScreen.position.set((-150),120,30);
  myScreen.rotation.y = Math.PI;
  
  scene.add(myScreen);

  	var movieGeometry = new THREE.PlaneGeometry( 400, 300, 1, 1 );
	

	var myBigScreen = new THREE.Mesh( movieGeometry, myMaterial );
	myBigScreen.position.set(0,0,0);
	myBigScreen.rotation.y = Math.PI;	
	scene.add(myBigScreen);

	var partnerBigScreen = new THREE.Mesh( movieGeometry, bigPartnerMaterial );
	partnerBigScreen.position.set(0,0,10);
	partnerBigScreen.rotation.y = Math.PI;	
	scene.add(partnerBigScreen);
	
	camera.position.set(0,10,300);
	camera.lookAt(partnerBigScreen.position);

// ?

	var onProgress = function ( xhr ) {
		if ( xhr.lengthComputable ) {
			var percentComplete = xhr.loaded / xhr.total * 100;
			console.log( Math.round(percentComplete, 2) + '% downloaded' );
		}
	};

	var onError = function ( xhr ) {
	};

// GUI
	gui = new dat.GUI();
	var sliders = new function() {


            this.showVideo = true;
            this.showFloor = true;
            this.shiftVideoX = 0;
            this.shiftVideoY = 0;
            this.scaleVideo = 1;
            this.rotateScreenZ = 270;	
            this.blendit = 'Multiply';

	}

	

	//VIDEO CONTROLLER FOLDER
	var f1 = gui.addFolder('Show/Hide Enviroment');
	//SHOW OR HIDE VIDEO SCREEN
	var videoShow = f1.add(sliders, 'showVideo');
	videoShow.onChange(function(value){
	myBigScreen.visible = value;
	});
	//SHOW OR HIDE FLOOR
		var floorShow = f1.add(sliders, 'showFloor');
		floorShow.onChange(function(value){
		floor.visible = value;	
		});

	//Video Rotate Z 
	var zRotV = f1.add(sliders, 'rotateScreenZ',0,360).step(1).name('rotateScreenZ').listen();;
	zRotV.onChange(function(value){
	console.log(value);
	value = map_range(value, 0, 360, 0, Math.PI*2);
	myBigScreen.rotation.z = value;

	// var message = {
	// 	'type' : 'rotateScreenZ',
	// 	'value' : value
	// };

	// message.type == 'scaleVideo'

	//socket
	//socket.send (JSON.stringify(message));

});		

//SHIFT VIDEO TEXTURE X POSITION
var xPosV = f1.add(sliders, 'shiftVideoX',0,200).step(1);
xPosV.onChange(function(value){
	console.log(value);
	myVideoXpos = value;
});	

var blend = gui.add( sliders, 'blendit', [ "Multiply", "Overlay", "Screen" ] ).name('Blending Type').listen();
	blend.onChange(function(value) {  

	console.log(value);


	

	if (value == "Multiply")
		value = THREE.MultiplyBlending ;
	else if (value == "Overlay")
		value = THREE.OverlayBlending;
	else if (value == "Screen")
		value = THREE.ScreenBlending ;
	
	mix = value; 

	bigPartnerMaterial.blending = mix;

	});




}



// ---------- ANIMATE -------------------
function animate() 
{
    requestAnimationFrame( animate );
	render();
	update();		
}



// ---------- UPDATE-------------------
function update()
{		
	if ( keyboard.pressed("p") ) // pause
		myVideo.pause();	
	//console.log('p');

	if ( keyboard.pressed("r") ) // resume
		myVideo.play();
	//console.log('r');
	if ( keyboard.pressed("s") ) // resume
		myBigScreen.visible = true;
	
	if ( keyboard.pressed("s") ) // resume
		myBigScreen.visible = false;

	
	controls.update();


	//THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });

}


// ---------- RENDER -------------------

function render() 
{	
	if ( myVideo.readyState === myVideo.HAVE_ENOUGH_DATA ) 
		myVideoCanvasContext.drawImage(myVideo, myVideoXpos, myVideoYpos , myVideo.width, myVideo.height, 0, 0, myVideoCanvas.width, myVideoCanvas.height);
	//myVideoCanvasContext.drawImage(myVideo, 0,0, );

	if(printed >0){
	console.log("myVideo width",myVideo.width );
	console.log("myVideo height",myVideo.height );
	console.log("myVideoCanvas width",myVideoCanvas.width );
	console.log("myVideoCanvas height",myVideoCanvas.height );
	}
	printed--;

	if ( myVideoTexture ) 
			myVideoTexture.needsUpdate = true;

 
if ( theirVideo.readyState === theirVideo.HAVE_ENOUGH_DATA )
theirVideoCanvasContext.drawImage(theirVideo, theirVideoXpos, theirVideoYpos , theirVideoCanvas.width, theirVideoCanvas.height, 0, 0, theirVideo.width*theirVideoZoom, theirVideo.height*theirVideoZoom); 

  if ( theirVideoTexture ) 
      theirVideoTexture.needsUpdate = true;
	
	if (alon != undefined) {
					alon.rotateOnAxis(new THREE.Vector3(0,1,0), angle);
				}	

	renderer.render( scene, camera );
}

// ----------	RADIAN TO DEGREES FUNCTION -------------
function map_range(value, low1, high1, low2, high2){
	
}



</script>

</body>
</html>


